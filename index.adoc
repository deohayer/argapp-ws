= argapp - a Python package for CLI application development
:toc: right
:toclevels: 3
:docinfo: shared
:nofooter:
:source-highlighter: pygments

== API

This chapter describes entities available to the developer and has a specific structure:

* Each subchapter represents a scope: packages, modules, classes etc.
The scope only has a description and an arbitrary number of sections.
* Each section represents either a variable or a function.
** The variable refers to variables, constants, fields, properties, etc.
It has a description with the declaration, and the following optional subsections:
*** Examples - usage examples.
*** Exceptions - exceptions when the variable is set to some invalid value.
*** Defaults - evaluation order if the variable is not set explicitly.
** The function refers to functions, methods, decorators, etc.
It has a description with the declaration, and the following optional subsections:
*** Examples - usage examples.
*** Parameters - a list of parameters accepted by the function.
*** Exceptions - exceptions when invalid parameter values are provided.
*** Returns - a list of possible return values.

'''

[#argapp]
=== `argapp`

The package is a module. It exports the following identifiers:

* <<argapp-arg,`Arg`>> - a class that represents a command line argument.
* <<argapp-app,`App`>> - a class that represents a command.
* <<argapp-callerror,`CallError`>> - an exception to raise when there is an error in <<app---call--,`+App.__call__()+`>>.
* <<argapp-main,`main()`>> - the main function: parses the command line and executes the commands.

'''

[#argapp-main]
==== `argapp.main(App, list[str])`

[source,python]
----
def main(
    app: App,
    argv: list[str] = sys.argv,
) -> None:
    ...
----

This is the main function of the script. It does the following:

. Parses `argv` and generates parameters `args` and `apps` for <<app---call--,`+App.__call__()+`>>.
. For each `app` in `apps` calls <<app---call--,`app(args, apps)`>>.
. Any exception is catched and printed.
. `sys.exit()` is called with an appropriate exit code.

===== Parameters

* `app` - the <<argapp-app,`App`>> instance to use as the main command.
* `argv` - the command line to parse, as a list of individual tokens: `['git', 'push', '--force', 'origin', 'main']`.
** Defaults to `sys.argv`.
** `os.path.basename(argv[0])` is used as the command name in the help text in case if `app.name` is `None`.

===== Exceptions

* `SystemExit`, if any `error` is raised:
** If the type of `error` is <<argapp-callerror,`CallError`>>, it is a user-friendly error:
*** The usage text is printed to `sys.stderr`, if the error originates from the parsing.
*** <<callerror-message,`error.message`>> is printed to `sys.stderr`, if not `None`.
*** `SystemExit(<<callerror-code,error.code>>)` is raised.
** If the type of `error` is not <<argapp-callerror,`CallError`>>, it is a developer-friendly error:
*** `str(error)` with its traceback is printed to `sys.stderr`.
*** `SystemExit(1)` is raised.
** `SystemExit(0)` is raised.

'''

[#argapp-arg]
=== `argapp.Arg`

A class which represents an optional or a positional argument.

* Positional arguments:
** Have unique value names within the same <<argapp-app,`App`>>.
** Always required. Setting <<arg-count,`count`>> to `'*'` and `'?'` mimics the optional behavior.
** Appear in the command line in a strict order.
* Optional arguments:
** Have unique short and long option names within the same <<argapp-app,`App`>>. The value name is not necessarily unique.
** Can be omitted completely unless marked as <<arg-required,`required`>>.
** Can appear in the command line in any order and be mixed with the positional. Providing optional arguments before positional is encouraged.

Important concepts:

* The same <<argapp-arg,`Arg`>> can be associated with multiple <<argapp-app,`App`>>.
* The value of <<argapp-arg,`Arg`>> is retrieved using the instance itself. It is usually necessary to store the constructed <<argapp-arg,`Arg`>>.
* All fields are properties. Note that "get" and "set" types do not match.
* Setting the field to `None` means that it will be implicitly re-evaluated according to "Defaults".

'''

[#arg-name]
==== `Arg.name`

[source,python]
----
class Arg:
    ...
    @property
    def name(self) -> str:
        ...

    @name.setter
    def name(self, v: str | None) -> None:
        ...
----

A name for the argument's value, if any: `LEVEL` in `-l, --level LEVEL`. +
Uniquely identifies a positional argument among the others in <<app-args,`App.args`>>.

===== Defaults

* Uppercase <<arg-lopt,`self.lopt`>>, if it is not `None`.
* Uppercase <<arg-sopt,`self.sopt`>>, if it is not `None`.
* `None`.

'''

[#arg-sopt]
==== `Arg.sopt`

[source,python]
----
class Arg:
    ...
    sopt: str | None = ...
----

A name for the argument's short option, if any: `l` in `-l, --level LEVEL`. +
Uniquely identifies an optional argument among the others in <<app-args,`App.args`>>.

===== Defaults

* `None`.

'''

[#arg-lopt]
==== `Arg.lopt`

[source,python]
----
class Arg:
    ...
    lopt: str | None = ...
----

A name for the argument's long option, if any: `level` in `-l, --level LEVEL`. +
Uniquely identifies an optional argument among the others in <<app-args,`App.args`>>.

===== Defaults

* `None`.

'''

[#arg-help]
==== `Arg.help`

[source,python]
----
class Arg:
    ...
    help: str | None = ...
----

A description of the argument:

* Appears next to the argument in the help text, if not `None`.
* All the newlines and spaces are retained.

===== Defaults

* `None`.

'''

[#arg-count]
==== `Arg.count`

[source,python]
----
class Arg:
    ...
    count: int | str = ...
----

A number of values consumed from the command line by the argument. Can be one of:

* 0 (only if <<arg-optional,`self.optional`>> is `True`).
* A positive integer value.
* `'?'`, 0 or 1 values.
* `'*'`, 0 or more values.
* `'+'`, 1 or more values.
* `'~'`, the rest of the command line (only if <<arg-positional,`self.positional`>> is `True`).

===== Defaults

* `'*'`, if the type of <<arg-default,`self.default`>>) is `list`.
* 1.

'''

[#arg-type]
==== `Arg.type`

[source,python]
----
class Arg:
    ...
    type: type = ...
----

A type of an individual value of the argument. Must be constructible from `str` (this requirement is not checked).

===== Defaults

* The type of the items in <<arg-choices,`self.choices`>>, if <<arg-choices,`self.choices`>> is not `None`.
* The type of the items in <<arg-default,`self.default`>>, if <<arg-multiple,`self.multiple`>> is `True`.
* The type of <<arg-default,`self.default`>>, if <<arg-default,`self.default`>> is not `None`.
* `str`.

'''

[#arg-default]
==== `Arg.default`

[source,python]
----
class Arg:
    ...
    default: object | list | None = ...
----

A default value to be used if the actual value was not provided. It is returned by the base implementations of <<arg---call--1, `+Arg.__call__()+`>> in the following cases:

 * If <<arg-count,`self.count`>> is `'?'` or `'*'`, and zero values are provided in the command line.
 * If <<arg-suppress,`self.suppress`>> is `False`, and the argument is not mentioned in the command line.

===== Defaults

* `False`, if <<arg-flag,`self.flag`>> is `True`.
* `[]`, if <<arg-count,`self.count`>> is `'*'`.
* `None`.

'''

[#arg-choices]
==== `Arg.choices`

[source,python]
----
class Arg:
    ...
    choices: dict | None = ...
----

A set of possible individual values for the argument. The dictionary keys are the possible values,
and the dictionary values, if not `None` or `''` are used as their descriptions in the help text.

Any `Iterable` can be used to initialize the value, it will be converted to `dict`, setting the dictionary values to `None`.

===== Defaults

* `None`.

'''

[#arg-repeat]
==== `Arg.repeat`

[source,python]
----
class Arg:
    ...
    repeat: bool = ...
----

Whether the argument can be repeated multiple times:

* If set to `True`, all values will be accumulated into a `list`.
* Unused if <<arg-positional,`self.positional`>> is `True`.

===== Defaults

* `False`.

'''

[#arg-required]
==== `Arg.required`

[source,python]
----
class Arg:
    ...
    required: bool = ...
----

Whether the argument must be set:

* If set to `True`, the optional argument must be mentioned in the command line.
* Unused if <<arg-positional,`self.positional`>> is `True`.

===== Defaults

* `False`.

'''

[#arg-suppress]
==== `Arg.suppress`

[source,python]
----
class Arg:
    ...
    suppress: bool = ...
----

Whether the argument must be set to <<arg-default,`self.default`>> if it is not mentioned in the command line.

* If set to `True`, the argument will not be set at all in `args` parameter of <<app---call--,`+App.__call__()+`>> if it is not mentioned in the command line.
* Unused if <<arg-positional,`self.positional`>> is `True`.

===== Defaults

* `False`.

'''

[#arg-restrict]
==== `Arg.restrict`

[source,python]
----
class Arg:
    ...
    restrict: bool = ...
----

Whether the argument values are restricted to <<arg-choices,`self.choices`>>.

===== Defaults

* `True`.

'''

[#arg-optional]
==== `Arg.optional`

[source,python]
----
class Arg:
    ...
    @property
    def optional(self) -> bool:
        ...
----

Whether the argument is optional:

* Opposite to <<arg-positional,`self.positional`>>.
* Cannot be set.

===== Defaults

* `True`, if <<arg-sopt,`self.sopt`>> or <<arg-lopt,`self.lopt`>> is not `None`.
* `False`.

'''

[#arg-positional]
==== `Arg.positional`

[source,python]
----
class Arg:
    ...
    @property
    def positional(self) -> bool:
        ...
----

Whether the argument is positional:

* Opposite to <<arg-optional,`self.optional`>>.
* Cannot be set.

===== Defaults

* `True`, if <<arg-sopt,`self.sopt`>> and <<arg-lopt,`self.lopt`>> are `None`.
* `False`.

'''

[#arg-precise]
==== `Arg.precise`

[source,python]
----
class Arg:
    ...
    @property
    def precise(self) -> bool:
        ...
----

Whether the argument consumes an exact number of values:

* Opposite to <<arg-variadic,`self.variadic`>>.
* Cannot be set.

===== Defaults

* `True`, if the type of <<arg-count,`self.count`>> is `int`.
* `False`.

'''

[#arg-variadic]
==== `Arg.variadic`

[source,python]
----
class Arg:
    ...
    @property
    def variadic(self) -> bool:
        ...
----

Whether the argument consumes a variable number of values:

* Opposite to <<arg-precise,`self.precise`>>.
* Cannot be set.

===== Defaults

* `True`, if `type(<<arg-count,self.count>>)` is `str`.
* `False`.

'''

[#arg-flag]
==== `Arg.flag`

[source,python]
----
class Arg:
    ...
    @property
    def flag(self) -> bool:
        ...
----

Whether the argument consumes no values:

* Can be `True` only if <<arg-single,`self.single`>> and <<arg-multiple,`self.multiple`>> are `False`.
* Cannot be set.

===== Defaults

* `True`, if <<arg-count,`self.count`>> is 0.
* `False`.

'''

[#arg-single]
==== `Arg.single`

[source,python]
----
class Arg:
    ...
    @property
    def single(self) -> bool:
        ...
----

Whether the argument can consume a single value:

* Can be `True` only if <<arg-flag,`self.flag`>> and <<arg-multiple,`self.multiple`>> are `False`.
* Cannot be set.

===== Defaults

* `True`, if <<arg-count,`self.count`>> is `'?'` or 1.
* `False`.

'''

[#arg-multiple]
==== `Arg.multiple`

[source,python]
----
class Arg:
    ...
    @property
    def multiple(self) -> bool:
        ...
----

Whether the argument can consume multiple values:

* Can be `True` only if <<arg-flag,`self.flag`>> and <<arg-single,`self.single`>> are `False`.
* Cannot be set.

===== Defaults

* `True`, if <<arg-count,`self.count`>> is `'*'`, `'+'` or greater than 1.
* `False`.

'''

[#arg---init--]
==== `+Arg.__init__(**)+`

[source,python]
----
class Arg:
    ...
    def __init__(
        self,
        name: str | None = ...,
        sopt: str | None = ...,
        lopt: str | None = ...,
        help: str | None = ...,
        count: int | str | None = ...,
        type: type | None = ...,
        default: object | Iterable | None = ...,
        choices: Iterable | None = ...,
        repeat: bool | None = ...,
        required: bool | None = ...,
        suppress: bool | None = ...,
        restrict: bool | None = ...,
    ) -> None:
        ...
----

Construct an instance.

===== Parameters

* `name` - corresponds to <<arg-name,`Arg.name`>>.
* `sopt` - corresponds to <<arg-sopt,`Arg.sopt`>>.
* `lopt` - corresponds to <<arg-lopt,`Arg.lopt`>>.
* `help` - corresponds to <<arg-help,`Arg.help`>>.
* `count` - corresponds to <<arg-count,`Arg.count`>>.
* `type` - corresponds to <<arg-type,`Arg.type`>>.
* `default` - corresponds to <<arg-default,`Arg.default`>>.
* `choices` - corresponds to <<arg-choices,`Arg.choices`>>.
* `repeat` - corresponds to <<arg-repeat,`Arg.repeat`>>.
* `required` - corresponds to <<arg-required,`Arg.required`>>.
* `suppress` - corresponds to <<arg-suppress,`Arg.suppress`>>.
* `restrict` - corresponds to <<arg-restrict,`Arg.restrict`>>.

===== Exceptions

* Propagates any exceptions caused by invalid parameters.

'''

[#arg---call--1]
==== `+Arg.__call__(bool)+`

[source,python]
----
class Arg:
    ...
    def __call__(v: bool) -> bool:
        ...
----

Return if the optional argument is mentioned or not. This overload is called if <<arg-flag,`self.flag`>> is `True`. +
Note that only the result of this function depends on <<arg-default,`self.default`>>, not the parameter.

===== Parameters

* `v` - `True`, if the argument is mentioned, `False` otherwise.

===== Returns

* <<arg-default,`self.default`>>, if `v` is `False`.
* Opposite to <<arg-default,`self.default`>>, if `v` is `True`.

'''

[#arg---call--2]
==== `+Arg.__call__(str | None)+`

[source,python]
----
class Arg:
    ...
    def __call__(v: str | None) -> object | None:
        ...
----

This overload is called if <<arg-single,`self.single`>> is `True` and <<arg-repeat,`self.repeat`>> is `False`.

===== Parameters

* `v` - `str` value, if provided in the command line. `None` otherwise.

===== Exceptions

* `CallError`, if the parsed `v` is not in <<arg-choices, `self.choices`>> and <<arg-restrict,`self.restrict`>> is `True`.
+
[source,python]
----
arg = Arg(name='arg', choices=[1, 2, 3])
arg('2')
# Invalid value of a positional argument "arg": 2. Must be one of:
#  * 1
#  * 2
#  * 3
----

===== Returns

* <<arg-default,`self.default`>>, if `v` is `None`.
* `<<arg-type,self.type>>(v)`.

'''

[#arg---call--3]
==== `+Arg.__call__(list[str] | None)+`

[source,python]
----
class Arg:
    ...
    def __call__(v: list[str] | None) -> list[object]:
        ...
----

This overload is called if <<arg-multiple,`self.multiple`>> is `True` and <<arg-repeat,`self.repeat`>> is `False`.

===== Parameters

* `v` - `list[str]` value, if provided in the command line. `None` otherwise.

===== Exceptions

* `CallError`, if any of parsed items of `v` is not in <<arg-choices, `self.choices`>> and <<arg-restrict,`self.restrict`>> is `True`.
+
[source,python]
----
arg = Arg(name='arg', count='*', choices=[1, 2, 3])
arg(['2', '4'])
# Invalid value of a positional argument "arg": 4. Must be one of:
#  * 1
#  * 2
#  * 3
----

===== Returns

* <<arg-default,`self.default`>>, if `v` is `None`.
* `list[<<arg-type,self.type>>]` constructed by converting each element of `v` to <<arg-type,`self.type`>>.

'''

[#arg---call--4]
==== `+Arg.__call__(list[str | None])+`

[source,python]
----
class Arg:
    ...
    def __call__(v: list[str | None]) -> list[object | None]:
        ...
----

This overload is called if <<arg-single,`self.single`>> is `True` and <<arg-repeat,`self.repeat`>> is `True`.

===== Parameters

* `v` - a `list` containing all values of the argument provided in the command line.
        Empty, if the argument was not mentioned.
        An element `None` is possible if <<arg-count,`self.count`>> is `'?'`.

===== Exceptions

* `CallError`, if any of parsed items of `v` is not in <<arg-choices, `self.choices`>> and <<arg-restrict,`self.restrict`>> is `True`.
+
[source,python]
----
arg = Arg(lopt='arg', repeat=True, choices=[1, 2, 3])
arg(['2', None, '4'])
# Invalid value of an optional argument "arg": 4. Must be one of:
#  * 1
#  * 2
#  * 3
----

===== Returns

* `list` with a single element <<arg-default,`self.default`>>, if `v` is empty and <<arg-default,`self.default`>> is not `None`.
* `list[<<arg-type,self.type>> | None]` constructed by:
** Converting each not `None` element of `v` to <<arg-type,`self.type`>>.
** Setting each `None` element of `v` to <<arg-default,`self.default`>>.

'''

[#arg---call--5]
==== `+Arg.__call__(list[list[str] | None]])+`

[source,python]
----
class Arg:
    ...
    def __call__(v: list[list[str] | None]) -> list[list[object]]:
        ...
----

This overload is called if <<arg-multiple,`self.multiple`>> is `True` and <<arg-repeat,`self.repeat`>> is `True`.

===== Parameters

* `v` - a `list` containing all lists of values of the argument provided in the command line.
        Empty, if the argument was not mentioned.
        An element `None` is possible if <<arg-repeat,`self.count`>> is `'*'`.

===== Exceptions

* `CallError`, if any of parsed items of `v` is not in <<arg-choices, `self.choices`>> and <<arg-restrict,`self.restrict`>> is `True`.
+
[source,python]
----
arg = Arg(lopt='arg', count='*', repeat=True, choices=[1, 2, 3])
arg([['2'], ['1', '2'], ['3', '4']])
# Invalid value of an optional argument "arg": 4. Must be one of:
#  * 1
#  * 2
#  * 3
----

===== Returns

* `list` with a single element <<arg-default,`self.default`>>, if `v` is empty and <<arg-default,`self.default`>> is not `[]` or `None`.
* `list[list[<<arg-type,self.type>>] | None]` constructed by:
** Converting each element of each not `None` element of `v` to <<arg-type,`self.type`>>.
** Setting each `None` element of `v` to <<arg-default,`self.default`>>.

'''

[#argapp-app]
=== `argapp.App`

A class that represents a command or a subcommand. It is supposed to be subclassed to handle the parsed command line in <<app---call--,`+App.__call__()+`>>. +

Important concepts:

* The same <<argapp-arg,`App`>> can be associated with multiple <<argapp-app,`App`>>.
* All fields are internally properties:
** "get" types can be seen in the field`s type hints for all fields.
** "set" types can be seen in the type hints of <<app---init--, `+App.__init__(**)+`>> for the writeable fields.
* Setting the field to `None` means that it will be implicitly re-evaluated according to "Defaults".

'''

[#app-name]
==== `App.name`

[source,python]
----
class App:
    ...
    name: str | None = ...
----

A name of the command. Uniquely identifies a command among the others in <<app-apps,`App.apps`>>.

===== Defaults

* `None`.

'''

[#app-help]
==== `App.help`

[source,python]
----
class App:
    ...
    help: str | None = ...
----

A short description of the command, appears in the parent's help text.

===== Defaults

* `None`.

'''

[#app-prolog]
==== `App.prolog`

[source,python]
----
class App:
    ...
    prolog: str | None = ...
----

A detailed description of the command, appears before the arguments list.

===== Defaults

* <<app-help,`self.help`>>.

'''

[#app-epilog]
==== `App.epilog`

[source,python]
----
class App:
    ...
    epilog: str | None = ...
----

A detailed description of the command, appears after the arguments list.

===== Defaults

* `None`.

'''

[#app-arg-help]
==== `App.arg_help`

[source,python]
----
class App:
    ...
    arg_help: Arg = ...
----

The argument for the help text:

* It is not added to <<app-args,`self.args`>>, not used as is, and serves only as a data provider.
* Only the <<arg-sopt,`sopt`>>, <<arg-lopt,`lopt`>> and <<arg-help,`help`>> are used, the rest is ignored.
* If <<arg-sopt,`sopt`>> and <<arg-lopt,`lopt`>> are `None`, the help text option is disabled.

===== Defaults

* `<<argapp-arg,Arg>>(sopt='h', lopt='help', help='Show the help text and exit.')`.

'''

[#app-arg-cmd]
==== `App.arg_cmd`

[source,python]
----
class App:
    ...
    arg_cmd: Arg = ...
----

The argument for the subcommand:

* It is not added to <<app-args,`self.args`>>, not used as is, and serves only as a data provider.
* Only the <<arg-name,`name`>> and <<arg-help,`help`>> are used, the rest is ignored.
* If <<arg-name,`name`>> is `None`, the help text option is disabled.

===== Defaults

* `<<argapp-arg,Arg>>(name='CMD', help='A subcommand to run.')`.

'''

[#app-args]
==== `App.args`

[source,python]
----
class App:
    ...
    @property
    def args(self) -> list[Arg]:
        ...
----

A list of arguments of the command. Cannot be set, but can be modified.

===== Defaults

* `[]`.

'''

[#app-apps]
==== `App.apps`

[source,python]
----
class App:
    ...
    @property
    def apps(self) -> list[App]:
        ...
----

A list of subcommands of the command. Cannot be set, but can be modified.

===== Defaults

* `[]`.

'''

[#app---init--]
==== `+App.__init__(**)+`

[source,python]
----
class App:
    ...
    def __init__(
        self,
        name: str | None = None,
        help: str | None = None,
        prolog: str | None = None,
        epilog: str | None = None,
        arg_help: Arg | None = None,
        arg_cmd: Arg | None = None,
    ) -> None:
        ...
----

Construct an instance.

===== Parameters

* `name` - corresponds to <<app-name,`App.name`>>.
* `help` - corresponds to <<app-help,`App.help`>>.
* `prolog` - corresponds to <<app-prolog,`App.prolog`>>.
* `epilog` - corresponds to <<app-epilog,`App.epilog`>>.
* `arg_help` - corresponds to <<app-arg-help,`App.arg_help`>>.
* `arg_cmd` - corresponds to <<app-arg-cmd,`App.arg_cmd`>>.

===== Exceptions

* Propagates any exceptions caused by invalid parameters.

'''

[#app---call--]
==== `+App.__call__(dict[Arg, object], list[App])+`

[source,python]
----
class App:
    ...
    def __call__(
        self,
        args: dict[Arg, object],
        apps: list[App],
    ) -> None:
        ...
----

This method is supposed to be overridden by in a subclass:

* The default implementation does nothing, no need to call.
* Use <<argapp-callerror,`CallError`>> to notify about errors, <<argapp-main,`main()`>> catches and prints them.

===== Parameters

* `args` - a dictionary of all parsed arguments and their values.
* `apps` - a call stack: the command and its subcommands mentioned in the command line.

'''

[#argapp-callerror]
=== `argapp.CallError`

A subclass of `RuntimeError`. These exceptions are supposed to be raised in <<app---call--,`+App.__call__()+`>>
with custom return code and error message in case of any errors during the execution.

The fields are checked upon setting. `None` is always a valid value which means that the field has to use its defaults.

'''

[#callerror-message]
==== `CallError.message`

[source,python]
----
class CallError(RuntimeError):
    ...
    message: str | None = ...
----

An error message. `None` means that no message is provided, nothing should be printed.

===== Defaults

* `None`.

'''

[#callerror-code]
==== `CallError.code`

[source,python]
----
class CallError(RuntimeError):
    ...
    code: int = ...
----

A value from 0 to 255 to inidcate an error (0 means no error).

===== Defaults

* 1.

'''

[#callerror---init--]
==== `+CallError.__init__(**)+`

[source,python]
----
class CallError(RuntimeError):
    ...
    def __init__(
        self,
        message: str | None = None,
        code: int | None = None,
    ) -> None:
        ...
----

Construct an instance.

===== Parameters

* `message` - corresponds to <<callerror-message,`CallError.message`>>.
* `code` - corresponds to <<callerror-code,`CallError.code`>>.

===== Exceptions

* Propagates any exceptions caused by invalid parameters.

'''

[#callerror---str--]
==== `+CallError.__str__()+`

[source,python]
----
class CallError(RuntimeError):
    ...
    def __str__(self) -> str:
        ...
----

Provide a string representation.

===== Returns

* `''`, if <<callerror-message,`self.message`>> is `None`.
* <<callerror-message,`self.message`>>.
